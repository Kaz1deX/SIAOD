#include <iostream>
#include <ctime>
#include <chrono>
#include <vector>
using namespace std;

void ShakerSort(vector<int>& A) // функция принимает указатель на массив и его размер
{
	long long CF = 0, MF = 0; // переменные, хранящие количество операций сравнения и количество операций перемещения

	auto start = chrono::high_resolution_clock::now(); // засечь время начала алгоритма
	int left = 0; // объявление переменной, которая хранит левую границу вектора и инициализация её нулём,
				  // так как вектор начинается с нулевого элемента
	int right = (A.size() - 1); // объявление переменной, которая хранит правую границу вектора и инициализируем
								// её количеством элементов веткора минус 1, так как нумерация начинается с нуля
	while (left < right) // условие на схожесть границ вектора, чтобы пока есть элементы между границами,
	{					 // продолжать сортировку
		CF++; // произошло одно сравнение
		for (int i = left; i < right; i++) // цикл проходит во всему вектору слева направо,
		{								   // передвигая наибольший элемент в правый край вектора
			CF++; // произошло одно сравнение
			if (A[i] > A[i + 1]) // условие на определение наибольшего элемента, если текущий элемент
			{					 // больше следующего, то их надо поменять
				CF++; // произошло одно сравнение
				swap(A[i], A[i + 1]); // поменять местами элементы массива
				MF++; // произошло одно перемещение
			}
		}
		right--; // уменьшить правую границу, так как один элемент уже встал на своё место справа

		for (int i = right; i > left; i--) // цикл проходит во всему вектору справа налево, передвигая
		{								   // наименьший элемент в левый край вектора
			CF++; // произошло одно сравнение
			if (A[i] < A[i-1]) // условие на определение наименьшего элемента, если текущий элемент
			{				   // меньше предыдущего, то их надо поменять
				CF++; // произошло одно сравнение
				swap(A[i-1], A[i]); // поменять местами элементы массива
				MF++; // произошло одно перемещение
			}
		}
		left++; // увеличить левую границу, так как один элемент уже встал на своё место слева
	}
	auto ending = chrono::high_resolution_clock::now(); // засечь время конца алгоритма

	chrono::duration<float> duration = ending - start; // вычесть из времени конца алгоритма время начала, чтобы узнать длительность алгоритма

	cout << "CF (количество сравнений) = " << CF << '\n'; // вывод на экран количества операций сравнения
	cout << "MF (количество перемещений) = " << MF << '\n'; // вывод на экран количества операций перемещения
	cout << "Time (время работы алгоритма) = " << duration.count() * 1000 << " ms" << '\n'; // вывод на экран длительность работы алгоритма в миллисекундах
	cout << "CF + MF (сумма операций) = " << CF + MF;
}

void Random(vector<int>& A, int n)
{
	//int value = 0;
	for (int i = 0; i < n; i++)
	{
		A.push_back((rand() % 10));

		//A.push_back(value);
		//value = value + 1;
	}
}

void Print(vector<int>& A)
{
	for (int i = 0; i < A.size(); i++)
	{
		cout << A[i] << ' ';
	}
}

int main()
{
	srand(time(NULL));
	setlocale(LC_ALL, "RUS");
	int n;
	cin >> n;
	vector<int> A;
	Random(A, n);
	cout << "Количество элементов: " << A.size() << '\n';
	//cout << "Исходный вектор:" << '\n';
	//Print(A);
	//cout << '\n';
	ShakerSort(A);
	//cout << '\n' << "Отсортированный вектор:" << '\n';
	//Print(A);
	return 0;
}



//for (int i = 0; i < (n - 1); i++) // цикл, который перебирает все элементы массива, кроме последнего
//{
//	CF = CF + 1; // произошло 1 сравнение
//	int min_i = i; // переменная хранит индекс найденного на данном этапе минимального элемента
//	for (int j = (i + 1); j < n; j++) // цикл, который ищет индекс минимального элемента
//	{
//		CF = CF + 1; // произошло 1 сравнение
//		if (A[j] < A[min_i]) // условие на то, чтобы данный элемент был меньше предполагаемого минимального элемента
//		{
//			min_i = j; // присвоить индекс найденного на данном этапе минимального элемента
//		}
//	}
//	swap(A[i], A[min_i]); // поменять местами элементы массива
//	MF = MF + 1; // произошло 1 перемещение
//}